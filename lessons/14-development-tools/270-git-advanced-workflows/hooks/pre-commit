#!/bin/bash
# .git/hooks/pre-commit
# Advanced pre-commit hook with multiple checks

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

echo -e "${BLUE}üîç Running pre-commit checks...${NC}"

# Function to check for debugging statements
check_debugging_statements() {
    echo "Checking for debugging statements..."
    
    local debug_patterns=(
        "console\.log"
        "console\.debug"
        "console\.warn"
        "debugger"
        "pdb\.set_trace"
        "import pdb"
        "binding\.pry"
        "puts.*debug"
        "var_dump"
        "print_r"
        "dd\("
        "dump\("
    )
    
    local files_with_debug=()
    
    for pattern in "${debug_patterns[@]}"; do
        while IFS= read -r -d '' file; do
            if git diff --cached --name-only | grep -q "^$file$"; then
                files_with_debug+=("$file")
            fi
        done < <(git diff --cached --name-only -z | xargs -0 grep -l "$pattern" 2>/dev/null || true)
    done
    
    if [ ${#files_with_debug[@]} -gt 0 ]; then
        echo -e "${RED}‚ùå Found debugging statements in staged files:${NC}"
        printf '%s\n' "${files_with_debug[@]}" | sort -u
        echo -e "${YELLOW}Please remove debugging statements before committing${NC}"
        return 1
    fi
    
    echo -e "${GREEN}‚úÖ No debugging statements found${NC}"
    return 0
}

# Function to check commit message format
check_commit_message() {
    local commit_msg_file="$1"
    local commit_msg=$(cat "$commit_msg_file")
    
    echo "Checking commit message format..."
    
    # Skip merge commits
    if [[ $commit_msg =~ ^Merge ]]; then
        echo -e "${GREEN}‚úÖ Merge commit detected, skipping format check${NC}"
        return 0
    fi
    
    # Check conventional commit format
    local commit_regex='^(feat|fix|docs|style|refactor|perf|test|chore|ci|build)(\(.+\))?: .{1,50}'
    
    if [[ ! $commit_msg =~ $commit_regex ]]; then
        echo -e "${RED}‚ùå Invalid commit message format${NC}"
        echo -e "${YELLOW}Format: type(scope): description${NC}"
        echo -e "${YELLOW}Types: feat, fix, docs, style, refactor, perf, test, chore, ci, build${NC}"
        echo -e "${YELLOW}Example: feat(auth): add JWT authentication${NC}"
        echo -e "${YELLOW}Current message: $commit_msg${NC}"
        return 1
    fi
    
    echo -e "${GREEN}‚úÖ Commit message format is valid${NC}"
    return 0
}

# Function to run linting
run_linting() {
    echo "Running linting checks..."
    
    # Check if package.json exists
    if [ -f "package.json" ]; then
        # Check for ESLint
        if npm list eslint >/dev/null 2>&1 || npm list @typescript-eslint/parser >/dev/null 2>&1; then
            echo "Running ESLint..."
            if ! npm run lint 2>/dev/null; then
                echo -e "${RED}‚ùå ESLint failed${NC}"
                return 1
            fi
        fi
        
        # Check for Prettier
        if npm list prettier >/dev/null 2>&1; then
            echo "Running Prettier..."
            if ! npm run format:check 2>/dev/null; then
                echo -e "${YELLOW}‚ö†Ô∏è  Prettier formatting issues found${NC}"
                echo -e "${YELLOW}Run 'npm run format' to fix formatting${NC}"
                return 1
            fi
        fi
    fi
    
    # Check for Python files
    local python_files=$(git diff --cached --name-only --diff-filter=ACM | grep '\.py$' || true)
    if [ -n "$python_files" ]; then
        # Check for flake8
        if command -v flake8 >/dev/null 2>&1; then
            echo "Running flake8..."
            if ! echo "$python_files" | xargs flake8; then
                echo -e "${RED}‚ùå flake8 failed${NC}"
                return 1
            fi
        fi
        
        # Check for black
        if command -v black >/dev/null 2>&1; then
            echo "Running black..."
            if ! echo "$python_files" | xargs black --check; then
                echo -e "${YELLOW}‚ö†Ô∏è  Black formatting issues found${NC}"
                echo -e "${YELLOW}Run 'black .' to fix formatting${NC}"
                return 1
            fi
        fi
        
        # Check for isort
        if command -v isort >/dev/null 2>&1; then
            echo "Running isort..."
            if ! echo "$python_files" | xargs isort --check-only; then
                echo -e "${YELLOW}‚ö†Ô∏è  Import sorting issues found${NC}"
                echo -e "${YELLOW}Run 'isort .' to fix imports${NC}"
                return 1
            fi
        fi
    fi
    
    echo -e "${GREEN}‚úÖ Linting checks passed${NC}"
    return 0
}

# Function to run tests
run_tests() {
    echo "Running tests..."
    
    # Check if package.json exists and has test script
    if [ -f "package.json" ] && grep -q '"test"' package.json; then
        echo "Running npm tests..."
        if ! npm test; then
            echo -e "${RED}‚ùå npm tests failed${NC}"
            return 1
        fi
    fi
    
    # Check for Python tests
    if [ -f "pytest.ini" ] || [ -f "setup.cfg" ] || [ -f "pyproject.toml" ] || [ -d "tests" ]; then
        if command -v pytest >/dev/null 2>&1; then
            echo "Running pytest..."
            if ! pytest --tb=short; then
                echo -e "${RED}‚ùå pytest failed${NC}"
                return 1
            fi
        fi
    fi
    
    echo -e "${GREEN}‚úÖ Tests passed${NC}"
    return 0
}

# Function to check file sizes
check_file_sizes() {
    echo "Checking file sizes..."
    
    local max_size=1048576  # 1MB in bytes
    local large_files=()
    
    while IFS= read -r -d '' file; do
        if [ -f "$file" ]; then
            local size=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null)
            if [ "$size" -gt "$max_size" ]; then
                large_files+=("$file ($(numfmt --to=iec "$size"))")
            fi
        fi
    done < <(git diff --cached --name-only --diff-filter=ACM -z)
    
    if [ ${#large_files[@]} -gt 0 ]; then
        echo -e "${YELLOW}‚ö†Ô∏è  Large files detected:${NC}"
        printf '%s\n' "${large_files[@]}"
        echo -e "${YELLOW}Consider using Git LFS for large files${NC}"
        echo -e "${YELLOW}Do you want to continue? (y/N)${NC}"
        read -r response
        if [[ ! $response =~ ^[Yy]$ ]]; then
            return 1
        fi
    fi
    
    echo -e "${GREEN}‚úÖ File size check passed${NC}"
    return 0
}

# Function to check for secrets
check_secrets() {
    echo "Checking for potential secrets..."
    
    local secret_patterns=(
        "password\s*=\s*['\"][^'\"]+['\"]"
        "api[_-]?key\s*=\s*['\"][^'\"]+['\"]"
        "secret\s*=\s*['\"][^'\"]+['\"]"
        "token\s*=\s*['\"][^'\"]+['\"]"
        "ACCESS_KEY"
        "SECRET_KEY"
        "PRIVATE_KEY"
        "-----BEGIN RSA PRIVATE KEY-----"
        "-----BEGIN OPENSSH PRIVATE KEY-----"
        "-----BEGIN PGP PRIVATE KEY-----"
    )
    
    local files_with_secrets=()
    
    for pattern in "${secret_patterns[@]}"; do
        while IFS= read -r -d '' file; do
            if git diff --cached --name-only | grep -q "^$file$"; then
                files_with_secrets+=("$file")
            fi
        done < <(git diff --cached --name-only -z | xargs -0 grep -l -i "$pattern" 2>/dev/null || true)
    done
    
    if [ ${#files_with_secrets[@]} -gt 0 ]; then
        echo -e "${RED}‚ùå Potential secrets found in staged files:${NC}"
        printf '%s\n' "${files_with_secrets[@]}" | sort -u
        echo -e "${YELLOW}Please review and remove any secrets before committing${NC}"
        return 1
    fi
    
    echo -e "${GREEN}‚úÖ No secrets detected${NC}"
    return 0
}

# Main execution
main() {
    local exit_code=0
    
    # Run all checks
    check_debugging_statements || exit_code=1
    check_secrets || exit_code=1
    check_file_sizes || exit_code=1
    run_linting || exit_code=1
    run_tests || exit_code=1
    
    if [ $exit_code -eq 0 ]; then
        echo -e "${GREEN}üéâ All pre-commit checks passed!${NC}"
    else
        echo -e "${RED}üí• Pre-commit checks failed${NC}"
        echo -e "${YELLOW}Fix the issues above and try committing again${NC}"
    fi
    
    exit $exit_code
}

# Run main function
main "$@"
